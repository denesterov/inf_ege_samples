# 25355

# Для F(n) трюков не нужно, ведь рекурсия неглубокая - примерно 673/4 итераций
def F(n):
    if n < 19:
        return 6 * (G(n - 7) - 36)
    else:
        return F(n - 4) + 3580

# будем запоминать уже найденные значения G(n) в массиве
G_cache = [None] * 250000
def G(n):
    # Если значение запрашивают повторно - выдавать его из массива
    if G_cache[n] != None:
        return G_cache[n]
    # Таким образом можно избегать размотки рекурсии

    if n < 248045:
        return G(n + 9) - 4
    else:
        return n / 20 + 28

# Но заполнять наш массив значений G нужно обязательно начиная с бОльших значений,
# ведь рекурсия растет снизу вверх
for n in range(250000 - 1, 0, -1):
    G_cache[n] = G(n)

# сам рассчет
print(F(673))
